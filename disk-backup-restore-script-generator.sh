#!/bin/sh -e

# backup restorte partitions by writing script files you can then choose to run
# some parts of by commenting
# Thus like clonezilla but most simple I can imagine

# Backup and Restore Script
# Usage: ./backup-restore.sh /dev/sdX target-dir
#
# dependencies: partclone, lsblk

die(){ echo "$1"; exit 1; }


usage(){
  die << EOF
Usage: $0 /dev/sdX /mnt/backup-dir gzip gunzip
will generate the backup and restore scripts

To backup - prefix lines by # if you want to omit a partition
  sh /mnt/backup-dir/backup.sh

To restore:
  ./restore.sh /mnt/backup-dir /dev/sda ""
  ./restore.sh /mnt/backup-dir /dev/nvme0n1 "p"
EOF
}

if [ "$#" -lt 2 ]; then
  usage
fi

DISK="$1"
TARGET_DIR="$2"

COMPRESSOR=${3:-gzip}
DECOMPRESS=${4:-gunzip}


[ -e  "$DISK" ] ||  die "$DISK not found"

DISK_PATH="$(dirname "$DISK")"
DATE=$(date +"%Y%m%d")


# Create target directory if it doesn't exist
mkdir -p "$TARGET_DIR"

# Backup each partition
echo "getting partition list $DISK..."
PARTITIONS=$(lsblk -ln -o NAME -x NAME "$DISK" | grep -E "^$(basename $DISK)[0-9]+")


# Backup partition table
PARTITION_TABLE_FILE="partition-table-sfdisk.dump"
BACKUP_SCRIPT=$TARGET_DIR/backup.sh
RESTORE_SCRIPT=$TARGET_DIR/restore.sh

cat > $BACKUP_SCRIPT << EOF
#!/bin/sh -e
# generated by https://github.com/MarcWeber/sh-disk-backup-restore-script-generator
# Additional partclone flags can be passed by export \$PARTCLONE_CLONE_ARGS="-a1 -W" to use CRC32 checksumming or allow file to be loop mountable
set -x
EOF

cat > $RESTORE_SCRIPT << EOFF
#!/bin/sh -e
# generated by https://github.com/MarcWeber/sh-disk-backup-restore-script-generator
usage(){
cat << EOF
	./restore.sh source-dir /dev/sda ""
	./restore.sh source-dir /dev/nvme0n1 "p"
EOF
exit 1
}
[ -n "\$1" ] || usage
[ -n "\$2" ] || usage
# [ -n "\$3" ] || usage
SOURCE_DIR="\$1"
TARGET_DEV="\$2"
TARGET_DEV_SEP="\$3"
set -x
EOFF

get_partition_number() {
    local device="$1"
    partition_number="${device##*[!0-9]}"
    echo $partition_number
}

ok_guard(){
  # resumability: Only run command if ok_file doesn't exist yet
  local ok_file=$1
  local command=$1
  echo "[ -f '$ok_file' ] || $command; touch '$ok_file'"
}

# PARTITION TABLE
ok_guard "$TARGET_DIR/$PARTITION_TABLE_FILE.ok" "sfdisk --dump "$DISK" > \"$TARGET_DIR/$PARTITION_TABLE_FILE\"" >> $BACKUP_SCRIPT


echo "# On Ubuntu you cannot write the microsoft reserved partition eventually, so change the type" >> $RESTORE_SCRIPT
# TODO -> is this compilicated way required ?
echo "cat  \$SOURCE_DIR/$PARTITION_TABLE_FILE  | sed 's@E3C9E316-0B5C-4DB8-817D-F92DF00215AE@EBD0A0A2-B9E5-4433-87C0-68B6B72699C7@' | sfdisk \$TARGET_DEV  " >> $RESTORE_SCRIPT

# EACH PARTITION
for PART in $PARTITIONS; do
    PART_NR=$(get_partition_number "$PART")
    PART_PATH="$DISK_PATH/$PART"
    FS_TYPE=$(lsblk -no FSTYPE "$PART_PATH")
    # maybe you need -C cause size check fails ?
    RECOVER_FLAGS=${RECOVER_FLAGS:--r -O}

    case $FS_TYPE in
            ntfs|ext4|ext3|ext2|xfs|btrfs|fat32|vfat|hfsplus)
		    BACKUP_PART_NAME="$PART_NR.$FS_TYPE.$COMPRESSOR"
		    ok_guard "$TARGET_DIR/$BACKUP_PART_NAME.ok" "partclone.${FS_TYPE} \$PARTCLONE_CLONE_ARGS -c -s '$PART_PATH' -x $COMPRESSOR > '$TARGET_DIR/$BACKUP_PART_NAME'" >> "$BACKUP_SCRIPT"
		    echo "cat \"\$SOURCE_DIR/$BACKUP_PART_NAME\" | $DECOMPRESS | partclone.$FS_TYPE ${RECOVER_FLAGS} \"\${TARGET_DEV}\${TARGET_DEV_SEP}$PART_NR\"" >> "$RESTORE_SCRIPT"

		    ;;
            *) 
		    FS_TYPE="dd" 
		    BACKUP_PART_NAME="$PART_NR.$FS_TYPE.$COMPRESSOR"
		    echo "partclone.${FS_TYPE} -s '$PART_PATH' | $COMPRESSOR > '$TARGET_DIR/$BACKUP_PART_NAME'" >> "$BACKUP_SCRIPT"
		    echo "cat \"\$SOURCE_DIR/$BACKUP_PART_NAME\" | $DECOMPRESS | partclone.$FS_TYPE ${RECOVER_FLAGS} \"\${TARGET_DEV}\${TARGET_DEV_SEP}$PART_NR\"" >> "$RESTORE_SCRIPT"
		    ;;
    esac

done

echo "# FIX type of >>microsoft reserved partition<< which eventually makes it readonly ?" >> $RESTORE_SCRIPT
echo "cat  \$SOURCE_DIR/$PARTITION_TABLE_FILE  | sfdisk \$TARGET_DEV  " >> $RESTORE_SCRIPT

echo "===BACKUP_SCRIPT"
cat $BACKUP_SCRIPT

echo "== RESTORE"
cat $RESTORE_SCRIPT

echo "SCRIPT COMPLETE $BACKUP_SCRIPT"
echo "SCRIPT COMPLETE $RESTORE_SCRIPT"
echo "TODO MBR !?"
